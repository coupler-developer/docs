# 엔지니어링 가드레일

## 주의할점

- 필수 코드만 추가
- 플랫폼 고려: android, ios일 때 레이아웃
- 프로젝트 일관성, 확장성, 재사용성 고려
- 추측 금지, 코드 및 링크로 근거 제시
- 기존 기능 삭제 금지
- 조용한 실패 금지: 로딩/검증/저장 실패는 사용자에게 명시적으로 알리고 로그/에러코드를 남긴다
- 불필요한 가드 금지: 정책상 불가능한 경로는 가드로 숨기지 말고 데이터/흐름 보증으로 해결한다
- 정책 의도는 코드에서 바로 드러나게 변수명/함수명/구조로 명시한다
- 주석 최소화: 코드로 의도가 충분히 드러나면 주석 금지, 불가피한 경우에만 1줄 주석 허용
- 한국어 사용, 영어단어는 알파뱃으로 표시
- 코드, 파일엔 명시적이며 직관적인 명칭 사용할 것
- lint/CI 통과를 merge 조건으로 둔다 (특히 docs 변경 시 markdownlint: MD012/MD032)
- verbose한 문법 지양
- Optional (`?`) 최소화: API/데이터 소스에서 반드시 제공하는 필드는 optional로 표시하지 않는다. 실제로 값이 없을 수 있는 경우에만 `?` 사용

## 코드 품질 정책

### API 스펙 명확성

- **불필요한 분기나 fallback 로직 금지**

  - API 파라미터는 하나로 명확하게 정의
  - `param1 ?? param2` 같은 fallback은 API 불일치를 숨김
  - 예시: `profile_image_paths ?? profile` (잘못됨) → `profile_image_paths` (올바름)
  - 이유: fallback은 클라이언트-서버 간 스펙 불일치를 감추어 디버깅을 어렵게 하고 향후 유지보수 시 혼란을 야기함

### `?.` / `??` 사용 규칙

- **스펙이 확정된 경로에서는 `?.` / `??`를 기본값으로 쓰지 않는다**

  - 타입/스펙이 맞으면 "항상 존재"가 원칙이다. `?.` / `??`는 런타임 문제를 조용히 숨길 수 있다.
  - 스펙이 깨질 수 있으면 데이터/스펙을 고정하거나, 불가능한 상태를 에러/로그/사용자 메시지로 드러내는 방식으로 해결한다
- **허용되는 경우**

  - 진짜로 optional인 필드(명세상 null/undefined가 가능)일 때
  - UI 편의(표시용)로 "없으면 빈 값"이 명확한 경우
- **금지되는 경우**

  - 키 중복/스펙 불일치를 fallback으로 감추는 코드(`a ?? b`, `obj?.a?.b ?? default` 형태로 "그럴듯하게" 맞추기)
  - 타입 오류를 없애기 위한 무분별한 `?.` / `??` 추가(마이그레이션 중 특히 금지)
- **lint로 바로 강제하지 않는 이유(현재 기준)**

  - 일부 레포의 lint는 `--max-warnings 0`로 실행된다. 그래서 `warn`으로 점진 도입이 어렵다.

### 스펙 위반을 숨기지 않기

- **normalize/resolve로 땜질 금지**

  - 예시: `normalizeAuthImages(...)`, `resolveXxx(...)`로 잘못된 스펙을 "그럴듯하게" 맞추는 코드 금지
  - 원칙: 스펙이 애매하면 API/DB 스키마부터 고정하고, 클라이언트는 그 스펙만 처리한다
- **스펙 위반은 에러로 드러내기**

  - 불가능한 상태는 `if (...) return;` 같은 조용한 가드로 숨기지 않는다
  - 사용자에게는 토스트/에러 메시지로 알리고, 개발 환경에서는 throw/log로 즉시 드러내기

### 타입/Optional 규칙

- **API가 항상 내려주는 필드면 Optional(`?`) 금지**

  - "언젠가 null일 수 있음"이라는 추측으로 `?`를 붙이지 않는다
  - 실제로 값이 없을 수 있는 케이스가 정의된 필드만 Optional로 둔다

- **`unknown`/`any` 최소화 (특히 API 응답 계약)**

  - 원칙: 앱이 소비하는 API 응답은 `unknown`으로 두지 않고, 실제 스키마 타입을 정의한다
  - `unknown`은 경계에서만 허용한다
    - 예: 외부 API/서드파티 SDK/raw JSON을 처음 받는 지점
    - 이후에는 `parse/validate`를 거쳐 도메인 타입으로 고정한다
  - “타입이 애매하니 일단 unknown”은 금지한다. 필요한 필드만이라도 타입으로 명시한다

- **`undefined` 금지, `null`로 고정**

  - JSON 응답에서 “없음”은 `undefined`(키 누락)로 표현하지 않고 `null`로 고정한다
  - 이유: `undefined vs null vs missing key` 분기는 곧 fallback/추측 로직을 만든다
  - 따라서 “항상 존재하지만 비어있을 수 있음”은 `field: T | null`로 고정한다 (Optional 아님)
- **단일 스펙 강제**

  - `images` vs `image`, `image_url` vs `url`처럼 중복 키를 동시에 허용하지 않는다
  - 배열이면 복수형, 단일 값이면 단수형을 강제하고, 스펙은 한 가지로 고정한다

- **요청(draft) 모델과 응답(response) 모델을 섞지 않기**

  - 서버 응답 필드를 클라이언트 로컬 draft 저장소로 재사용하지 않는다
  - 예: `profile_set_current`(응답 계약)를 로컬에서 임의 shape로 overwrite해서 제출 payload에 쓰는 방식 금지
  - 제출 payload는 요청 스펙(`profile_image_paths` 등)으로만 구성하고, 응답 스펙은 오직 서버 응답으로만 갱신한다

- **서버 enum과 로컬 상태를 섞지 않기**

  - 서버에서 내려오는 상태코드(enum)는 서버 enum 그대로만 사용한다
  - 로컬 UI에서만 필요한 draft/임시 상태는 별도 로컬 enum/필드로 분리한다 (서버 enum 값 재사용 금지)

### 명시적인 이름 사용

- **모호한 이름 금지, 의미가 명확한 이름 사용**

  - `profile` (모호함) → `profile_image_paths` (명시적)
  - `data` (모호함) → `memberData` 또는 `authData` (명시적)

- **단수/복수 구분 엄격히 준수**

  - `image` (단일 이미지) vs `images` (복수 이미지)
  - `url` (단일 URL) vs `urls` (복수 URL)
  - 배열이면 반드시 복수형, 단일 값이면 반드시 단수형

- **타입과 일치하는 명명**

  - 문자열 배열: `imageUrls` (O), `imageUrl` (X)
  - '#' 구분자 문자열: `profileImagesString` 또는 `profileImagesConcatenated` (O), `profile` (X)

## 네이밍 전환 메모

- ritzy -> coupler로 전체적인 개명 필요
- 기존 코드 전체를 한 번에 바꾸기에는 변경이 크므로, 변경분에 대해서만 앞으로 명칭을 coupler로 고정한다
