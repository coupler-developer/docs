# 엔지니어링 가드레일

## 핵심 원칙

- **Fail-closed**: 예상하지 못한 상태는 조용히 넘기지 않고 즉시 실패시킨다. 코드를 읽는 사람이 추측 없이 의도를 파악할 수 있어야 한다
  - 조용한 실패 금지: 실패는 사용자에게 명시적으로 알리고 로그/에러코드를 남긴다
  - 우회 금지: fallback/normalize/resolve로 문제를 덮지 않는다. 스펙이 맞지 않으면 스펙을 고친다
  - 불필요한 가드 금지: 불가능한 경로는 가드로 숨기지 말고 데이터/흐름 보증으로 해결한다
  - 정책 의도는 코드에서 바로 드러나게 변수명/함수명/구조로 명시한다
- **추측 금지**: 코드 및 링크로 근거를 제시한다
- **일관성**: 같은 문제는 같은 방식으로 해결한다. 코드, 파일, 문서에서 중복을 만들지 않는다

## 코딩 규칙

### API 스펙/계약

- **API 파라미터는 하나로 명확하게 정의한다**
  - `param1 ?? param2` 같은 fallback은 API 불일치를 숨긴다
  - 예시: `profile_image_paths ?? profile` (잘못됨) → `profile_image_paths` (올바름)
- **normalize/resolve로 땜질 금지**
  - 예시: `normalizeAuthImages(...)`, `resolveXxx(...)`로 잘못된 스펙을 맞추는 코드 금지
  - 스펙이 애매하면 API/DB 스키마부터 고정하고, 클라이언트는 그 스펙만 처리한다
- **스펙 위반은 에러로 드러내기**
  - `if (...) return;` 같은 조용한 가드로 숨기지 않는다
  - 사용자에게는 토스트/에러 메시지, 개발 환경에서는 throw/log로 즉시 드러내기
- **요청(draft) 모델과 응답(response) 모델을 섞지 않기**
  - 서버 응답 필드를 클라이언트 로컬 draft 저장소로 재사용하지 않는다
  - 제출 payload는 요청 스펙으로만 구성하고, 응답 스펙은 오직 서버 응답으로만 갱신한다
- **서버 enum과 로컬 상태를 섞지 않기**
  - 서버 상태코드는 서버 enum 그대로만 사용한다
  - 로컬 UI 전용 draft/임시 상태는 별도 로컬 enum/필드로 분리한다

### 타입/Optional

- **API가 항상 내려주는 필드면 Optional(`?`) 금지**
  - "언젠가 null일 수 있음"이라는 추측으로 `?`를 붙이지 않는다
  - 실제로 값이 없을 수 있는 케이스가 정의된 필드만 Optional로 둔다
- **`unknown`/`any` 최소화**
  - API 응답은 `unknown`으로 두지 않고 실제 스키마 타입을 정의한다
  - `unknown`은 경계(외부 API/서드파티 SDK/raw JSON)에서만 허용, 이후 parse/validate로 도메인 타입 고정
  - "타입이 애매하니 일단 unknown"은 금지. 필요한 필드만이라도 타입으로 명시한다
- **`undefined` 금지, `null`로 고정**
  - JSON 응답에서 "없음"은 `null`로 고정한다 (`field: T | null`)
  - `undefined vs null vs missing key` 분기는 fallback/추측 로직을 만든다
- **단일 스펙 강제**
  - 중복 키(`images` vs `image`, `image_url` vs `url`) 동시 허용 금지
  - 배열이면 복수형, 단일 값이면 단수형, 스펙은 한 가지로 고정

### `?.` / `??` 사용 규칙

- **스펙이 확정된 경로에서는 `?.` / `??`를 기본값으로 쓰지 않는다**
  - 타입/스펙이 맞으면 "항상 존재"가 원칙. `?.` / `??`는 런타임 문제를 조용히 숨길 수 있다
  - 스펙이 깨질 수 있으면 데이터/스펙을 고정하거나, 에러/로그/사용자 메시지로 드러내기
- **허용**: 진짜 optional 필드, UI 편의(표시용)로 "없으면 빈 값"이 명확한 경우
- **금지**: 키 중복/스펙 불일치를 fallback으로 감추기, 타입 오류를 없애기 위한 무분별한 추가
- **lint 미적용 이유**: 일부 레포의 lint가 `--max-warnings 0`이라 `warn` 점진 도입이 어려움

### 네이밍

- **모호한 이름 금지, 의미가 명확한 이름 사용**
  - `profile` (모호) → `profile_image_paths` (명시적)
  - `data` (모호) → `memberData` 또는 `authData` (명시적)
- **단수/복수 구분 엄격히 준수**
  - 배열이면 반드시 복수형, 단일 값이면 반드시 단수형
- **타입과 일치하는 명명**
  - 문자열 배열: `imageUrls` (O), `imageUrl` (X)
  - '#' 구분자 문자열: `profileImagesString` (O), `profile` (X)

### 문법/스타일

- 삼항 연산자는 한 표현식에서 1회까지만 허용. 중첩(`a ? b : c ? d : e`) 금지, 분기 2개 초과 시 `if/else`
- 주석 최소화: 코드로 의도가 충분히 드러나면 주석 금지, 불가피한 경우에만 1줄
- verbose한 문법 지양
- 하드코딩/Magic Number 금지: 상수로 정의한다

### 버그 수정

- 증상이 아닌 근본 원인을 추적하여 제거한다

**체크리스트**:

- [ ] 근본 원인 파악했는가?
- [ ] 다른 곳에도 같은 문제 있는가?
- [ ] Edge case 테스트했는가?
- [ ] 회귀 테스트 통과했는가?

## 설계 원칙

### DB 설계

- **정규화 우선**: 동일 데이터를 여러 테이블에 중복 저장하지 않는다
- **복잡한 상태 조회는 VIEW로 제공**: 여러 테이블을 JOIN해야 하는 복잡한 상태 표현은 클라이언트/API에 떠넘기지 않고 DB VIEW로 만들어 제공한다
  - 예: `v_member_review_status` — 심사 상태를 여러 테이블에서 조합하여 하나의 VIEW로 노출

### API 계층

- **클라이언트-서버 책임 분리**: 비즈니스 판단(상태 전이, 자격 검증 등)은 서버에서 처리하고, 클라이언트(React Native/React)는 UI 표시와 사용자 입력 전달만 담당한다

### 비즈니스 로직 배치

- **로직 배치 기준**:
  - DB: 데이터 무결성 보장 (제약 조건, 트리거, VIEW)
  - API 서버: 비즈니스 규칙, 상태 전이, 권한 검증
  - 클라이언트: UI 렌더링, 사용자 입력, 표시용 가공만
- **같은 로직이 클라이언트와 서버에 동시에 존재하면 안 된다**: 서버가 판단하고, 클라이언트는 서버 응답에 따라 표시한다

## 프로세스

- 필수 코드, 파일만 추가 (무분별한 파일 생성, 커밋 금지)
- 기존 기능 삭제 금지
- 플랫폼 고려: android, ios일 때 레이아웃
- 프로젝트 일관성, 확장성, 재사용성 고려
- 한국어 사용, 영어단어는 알파뱃으로 표시
- 코드, 파일엔 명시적이며 직관적인 명칭 사용할 것
- lint/CI 통과를 merge 조건으로 둔다 (특히 docs 변경 시 markdownlint: MD012/MD032)

## 네이밍 전환 메모

- ritzy -> coupler로 전체적인 개명 필요
- 기존 코드 전체를 한 번에 바꾸기에는 변경이 크므로, 변경분에 대해서만 앞으로 명칭을 coupler로 고정한다
